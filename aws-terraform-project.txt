----------------------------------------------------------------------------------------------------------

*** AWS 3 Tier Application Project Using Terraform ***

001. Create aws-terraform project folder and configure backend.

- Configure <root/backend.tf> file to store terraform state metadata and lock the state file for teamwork.


terraform {
  cloud {
    organization = "uzbek"

    workspaces {
      name = "devops"
    }
  }
}


- Enter command <terraform login> in the cli to request API token in terraform cloud.
- Press the link on cli and give a name for token. Copy the generated API token and paste in the cli.
- Initialize by passing the command <terraform init>. In terraform cloud, go to <Settings> - <General>
  and choose <Local> option so plan and apply occur on local machine.

----------------------------------------------------------------------------------------------------------

002. Configure AWS provider.

- Create <root/providers.tf file>


terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

provider "aws" {
  region = var.aws_region     # passed region variable name from <root/variables.tf> file.
}


- Create <root/variables.tf> file.


# This Region value will be referenced in <root/providers.tf> file.

variable "aws_region" {
  default = "us-east-1"       # passed region variable in <root/providers.tf> file.
}


- Run <terraform init> to download plugins and initialize the provider.

----------------------------------------------------------------------------------------------------------

003. Create VPC resource.

- Create <root/networking> module folder.
- Inside networking folder create <main.tf>, <outputs.tf> and <variables.tf> files.
- In <root/networking/main.tf> file create VPC resources.


# This resource creates random integer which allows to assign new random number to VPC.
resource "random_integer" "random" {
  min = 1           # Assigns the lowest number.
  max = 100         # Assigns the highest number.
}

# This resource creates AWS VPC.

resource "aws_vpc" "mtc_vpc" {
  cidr_block           = var.vpc_cidr   # CIDR is referenced from <networking/variables.tf> file.
  enable_dns_hostnames = true           # Must enable dns hostname and support to provide hostname.
  enable_dns_support   = true

  # This tags name is going to be passed to AWS.

  tags = {
    Name = "mtc_vpc-${random_integer.random.id}"   # Referenced random integer resource to assign random integer ID.
  }

  # This lifecycle policy will force vpc destruction until new VPC is created so IGW can associate with first.
    Otherwise, if VPC is destroyed first, for IGW there is no VPC to associate with, so "terraform destroy" will time out.
  }
  lifecycle {
    create_before_destroy = true
  }
}


- Configure the values in <networking/variables.tf> file which references in <networking/main.tf> file.


# This variable being referenced in VPC resource in <networking/main.tf>

variable "vpc_cidr" {   # Referenced from "vpc_cidr" in <root/main.tf>, <networking/main.tf, variables.tf> files.
  type = string
}

variable "access_ip" {  # Referenced from <root/mainl.tf>, <networking/main.tf, variables.tf> files and passed to security group resources.
  type = string
}


- Configure <networking/outputs.tf> file so that <root/main.tf> can consume VPC outputs from <networking/main.tf> to create VPC
  and pass them on to other modules.


# This out will be consumed by <root/main.tf> VPC module block to create VPC.

output "vpc_id" {
  value = aws_vpc.mtc_vpc.id
}


- In <root/main.tf> file create module and reference VPC resource from <networking/main.tf> file.


# Deploys <networking/main.tf> resources.

module "networking" {
  source   = "./networking"   # Referencing to <root/networking> module
  vpc_cidr = "10.123.0.0/16"  # This value goes to <networking/variables.tf> then <networking/main.tf> which is <var.vpc_cidr>
}


- Run <terraform fmt -recursive> to format and clean the code.
- Run <terraform init> to initialize plugins and new resources.
- Run <terraform validate> to validate the code.
- Run <terraform plan> to see which resources will be created.
- Run <terraform apply --auto-approve> to deploy the resources.

----------------------------------------------------------------------------------------------------------

004. Create Public and Private Subnets and CIDR blocks.


- First create "locals" block so that I don't repeat and have value in one place and reference elsewhere.


locals {
  vpc_cidr = "10.123.0.0/16"  # Referenced to "vpc_cidr", "private_cidrs" and "public_cidrs" below.
}


- In <root/main.tf> file update "networking" module to reference "networking" module.


# Deploy Networking Resources

module "networking" {
  source           = "./networking"
  vpc_cidr         = local.vpc_cidr   # Referenced from "locals" block above.
  private_sn_count = 3    # Creates 3 private subnets of odd numbers: 10.123.1.0/24, 10.123.3.0/24, 10.123.5.0/24
  public_sn_count  = 2    # Creates 2 public subnets of even numbers: 10.123.2.0/24, 10.123.4.0/24
  max_subnets      = 20   # Creates needed subnets. Referenced from <networking.variables.tf> file.
  private_cidrs    = [for i in range(1, 255, 2) : cidrsubnet(local.vpc_cidr, 8, i)]   # cidr_block referenced from "locals" block above.
  public_cidrs     = [for i in range(2, 255, 2) : cidrsubnet(local.vpc_cidr, 8, i)]   # cidr_block referenced from "locals" block above.
  max_subnets      = 20
  access_ip        = var.access_ip    # referenced from <networking.main.tf, variables.tf> files.
  security_groups  = local.security_groups
}

# I used for loop with cidrsubnet function and range method which calculates a subnet addresses within assigns dynamic range of IP address prefixes.
Example of assigning IP addresses dynamically: 
On the CLI type "terraform console" and pass the for loop function: [for i in range(1, 255, 2) : cidrsubnet("10.123.0.0/16", 8, i)]
For private_cidrs, for index of in range of 1 to 255 steps over by 2 and calculates from cidrsubnet of 10.123.0.0/16, increment to 8
which would be /24 and increase it by 1 which gives result of 10.123.1.0/24.
For public_cidrs, for index of in range of 2 to 255 steps over by 2 and calculates from cidrsubnet of 10.123.0.0/16, increment to 8
which would be /24 and increase it by 1 which gives result of 10.123.1.0/24.


- Once finished updating module "networking" in <root/main.tf>, reference them in <networking/variables.tf> file.


# Created these variables in <networking/variables.tf> and referenced to module "networking" block in <root/main.tf> file.

variable "vpc_cidr" {}
variable "public_cidrs" {}
variable "private_cidrs" {}
variable "public_sn_count" {}
variable "private_sn_count" {}
variable "max_subnets" {}
variable "access_ip" {}


- Next create data source for AZ, public and private aws_subnet resource in <networking/main.tf> file.


# This data source enables to assign random Availability zone for each subnet which mitigates running out of AZs.

data "aws_availability_zones" "available" {}  # Referenced in aws_subnet resource.


- Create random_shuffle resource to randomly shuffle AZs and assign subnet to each shuffled AZs so I don't run out of AZs.


resource "random_shuffle" "public_az" {
  input        = data.aws_availability_zones.available.names    # Referenced to AZ data source above.
  result_count = var.max_subnets    # Referenced to max_subnets in <networking/variables.tf>
}


# This resource creates public Subnets.

resource "aws_subnet" "mtc_public_subnet" {
  count                   = var.public_sn_count   # Referenced from <root/main.tf> "networking" module and variables.tf file.
  vpc_id                  = aws_vpc.mtc_vpc.id    # Referenced from <root/main.tf> "networking" module and variables.tf file.
  cidr_block              = var.public_cidrs[count.index] # Pulls the cidr blocks one by one and assigns to each subnet.
  map_public_ip_on_launch = true                  # Automatically maps public IP to public subnet on launch.
  availability_zone       = random_shuffle.public_az.result[count.index]  # Referenced from random_shuffle resource above.

  tags = {
    Name = "mtc_public_${count.index + 1}"
  }
}

# This resource creates private Subnets.

resource "aws_subnet" "mtc_private_subnet" {
  count                   = var.private_sn_count  # Referenced from <root/main.tf> "networking" module and variables.tf file.
  vpc_id                  = aws_vpc.mtc_vpc.id    # Referenced from <root/main.tf> "networking" module and variables.tf file.
  cidr_block              = var.private_cidrs[count.index]  # Pulls the cidr blocks one by one and assigns to each subnet.
  map_public_ip_on_launch = false                 # Doesn't map public IP on launch thus it becomes private subnet.
  availability_zone       = random_shuffle.public_az.result[count.index]  # Referenced from random_shuffle resource above.

  tags = {
    Name = "mtc_private_${count.index + 1}"
  }
}


- Run <terraform fmt -recursive> to format and clean the code.
- Run <terraform init> to initialize plugins and new resources.
- Run <terraform validate> to validate the code.
- Run <terraform plan> to see which resources will be created.
- Run <terraform apply --auto-approve> to deploy the resources.
- Run <terraform destroy --auto-approve> to destroy the resources.

----------------------------------------------------------------------------------------------------------

005. Create Route Tables and The Internet Gateway.

- Create aws_internet_gateway resource in <networking/main.tf> file.


resource "aws_internet_gateway" "mtc_internet_gateway" {
  vpc_id = aws_vpc.mtc_vpc.id

  tags = {
    Name = "mtc_igw"
  }
}


- Create public "aws_route_table" in <networking/main.tf> file.


resource "aws_route_table" "mtc_public_rt" {
  vpc_id = aws_vpc.mtc_vpc.id

  tags = {
    Name = "mtc_public"
  }
}


- Create default public "aws_route" in <networking/main.tf> file to auto assign to default route 
  if no public route table explicitly specified.


resource "aws_route" "default_route" {
  route_table_id         = aws_route_table.mtc_public_rt.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.mtc_internet_gateway.id
}


- Create private "aws_default_route_table" in <networking/main.tf> file to auto assign private route tables if there is no
  explicit route table is specified.


resource "aws_default_route_table" "mtc_private_rt" {
  default_route_table_id = aws_vpc.mtc_vpc.default_route_table_id

  tags = {
    Name = "mtc_private"
  }
}


- Create "aws_route_table_association" in <networking/main.tf> file to associate public RTs with public subnets.


resource "aws_route_table_association" "mtc_public_assoc" {
  count          = var.public_sn_count  # Referenced from <root/main.tf> "networking" module, and <networking/variables.tf> file.
  subnet_id      = aws_subnet.mtc_public_subnet.*.id[count.index] # Referenced "aws_subnet" resource above. ".*.id[count.index]" all subnets.
  route_table_id = aws_route_table.mtc_public_rt.id
}


- Run <terraform fmt -recursive> to format and clean the code.
- Run <terraform init> to initialize plugins and new resources.
- Run <terraform validate> to validate the code.
- Run <terraform plan> to see which resources will be created.
- Run <terraform apply --auto-approve> to deploy the resources.
- Run <terraform destroy --auto-approve> to destroy the resources.

----------------------------------------------------------------------------------------------------------

006. Create VPC Security Groups.

- Create "aws_security_group" resource in <networking.main.tf> file.


# This resource creates public Security Group.

resource "aws_security_group" "mtc_sg" {
  for_each    = var.security_groups
  name        = each.value.name
  description = each.value.description
  vpc_id      = aws_vpc.mtc_vpc.id



  #public Security Group
  dynamic "ingress" {
    for_each = each.value.ingress
    content {
      from_port   = ingress.value.from
      to_port     = ingress.value.to
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"    # Value "-1" means all protocols.
    cidr_blocks = ["0.0.0.0/0"]
  }
}


- In <networking/validates.tf> file create variable for "access_ip" to reference "cidr_blocks" in "dynamic ingress" 
  of Public Security Group. And also reference in <root/main.tf> and <root/terraform.tfvars> files which I have already
  resourced above.
- Create <root/terraform.tfvars> file to store credentials such as IP addresses. This file must be included in .gitignore file.


access_ip = "0.0.0.0/0"


This "access_ip" is passed from <root/terraform.tfvars> to <root/variables.tf> to <root/main.tf> to <networking/variables.tf> 
and finally "access_ip" is specified in <networking/main.tf> of "aws_security_group" resource at "cidr_blocks = [var.access_ip]"


