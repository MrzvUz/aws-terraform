----------------------------------------------------------------------------------------------------------

*** AWS 3 Tier Application Project Using Terraform ***

001. Create aws-terraform project folder and configure backend.

- Configure <root/backend.tf> file to store terraform state metadata and lock the state file for teamwork.


terraform {
  cloud {
    organization = "uzbek"

    workspaces {
      name = "devops"
    }
  }
}


- Enter command <terraform login> in the cli to request API token in terraform cloud.
- Press the link on cli and give a name for token. Copy the generated API token and paste in the cli.
- Initialize by passing the command <terraform init>. In terraform cloud, go to <Settings> - <General>
  and choose <Local> option so plan and apply occur on local machine.

----------------------------------------------------------------------------------------------------------

002. Configure AWS provider.

- Create <root/providers.tf file>


terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

provider "aws" {
  region = var.aws_region     # passed region variable name from <root/variables.tf> file.
}


- Create <root/variables.tf> file.


# This Region value will be referenced in <root/providers.tf> file.

variable "aws_region" {
  default = "us-east-1"       # passed region variable in <root/providers.tf> file.
}


- Run <terraform init> to download plugins and initialize the provider.

----------------------------------------------------------------------------------------------------------

003. Create VPC resource.

- Create <root/networking> module folder.
- Inside networking folder create <main.tf>, <outputs.tf> and <variables.tf> files.
- In <root/networking/main.tf> file create VPC resources.


# This resource creates random integer which allows to assign new random number to VPC.
resource "random_integer" "random" {
  min = 1           # Assigns the lowest number.
  max = 100         # Assigns the highest number.
}

# This resource creates AWS VPC.

resource "aws_vpc" "mtc_vpc" {
  cidr_block           = var.vpc_cidr   # CIDR is referenced from <networking/variables.tf> file.
  enable_dns_hostnames = true           # Must enable dns hostname and support to provide hostname.
  enable_dns_support   = true

  tags = {
    Name = "mtc_vpc-${random_integer.random.id}"   # Referenced random integer resource to assign random integer ID.
  }
}


- Configure the values in <networking/variables.tf> file which references in <networking/main.tf> file.


# This variable being referenced in VPC resource in <networking/main.tf>

variable "vpc_cidr" {
  type = string
}


- Configure <networking/outputs.tf> file so that <root/main.tf> can consume VPC outputs from <networking/main.tf> to create VPC
  and pass them on to other modules.


# This out will be consumed by <root/main.tf> VPC module block to create VPC.

output "vpc_id" {
  value = aws_vpc.mtc_vpc.id
}


- In <root/main.tf> file create module and reference VPC resource from <networking/main.tf> file.


# Deploys <networking/main.tf> resources.

module "networking" {
  source   = "./networking"   # Referencing to <root/networking> module
  vpc_cidr = "10.123.0.0/16"  # This value goes to <networking/variables.tf> then <networking/main.tf> which is <var.vpc_cidr>
}


- Run <terraform fmt -recursive> to format and clean the code.
- Run <terraform init> to initialize plugins and new resources.
- Run <terraform validate> to validate the code.
- Run <terraform plan> to see which resources will be created.
- Run <terraform apply --auto-approve> to deploy the resources.

----------------------------------------------------------------------------------------------------------

004. Create Public and Private Subnets and CIDR blocks.

- In <root/main.tf> file update "networking" module to reference "networking" module.


# Deploy Networking Resources

module "networking" {
  source           = "./networking"
  vpc_cidr         = "10.123.0.0/16"
  private_sn_count = 3    # Creates 3 private subnets of odd numbers: 10.123.1.0/24, 10.123.3.0/24, 10.123.5.0/24
  public_sn_count  = 2    # Creates 2 public subnets of even numbers: 10.123.2.0/24, 10.123.4.0/24
  max_subnets      = 20   # Creates needed subnets. Referenced from <networking.variables.tf> file.
  private_cidrs    = [for i in range(1, 255, 2) : cidrsubnet("10.123.0.0/16", 8, i)]
  public_cidrs     = [for i in range(2, 255, 2) : cidrsubnet("10.123.0.0/16", 8, i)]
}

# I used for loop with cidrsubnet function and range method which calculates a subnet addresses within assigns dynamic range of IP address prefixes.
Example of assigning IP addresses dynamically: 
On the CLI type "terraform console" and pass the for loop function: [for i in range(1, 255, 2) : cidrsubnet("10.123.0.0/16", 8, i)]
For private_cidrs, for index of in range of 1 to 255 steps over by 2 and calculates from cidrsubnet of 10.123.0.0/16, increment to 8
which would be /24 and increase it by 1 which gives result of 10.123.1.0/24.
For public_cidrs, for index of in range of 2 to 255 steps over by 2 and calculates from cidrsubnet of 10.123.0.0/16, increment to 8
which would be /24 and increase it by 1 which gives result of 10.123.1.0/24.


- Once finished updating module "networking" in <root/main.tf>, reference them in <networking/variables.tf> file.


# Created these variables in <networking/variables.tf> and referenced to module "networking" block in <root/main.tf> file.

variable "vpc_cidr" {}
variable "public_cidrs" {}
variable "private_cidrs" {}
variable "public_sn_count" {}
variable "private_sn_count" {}
variable "max_subnets" {}


- Next create data source for AZ, public and private aws_subnet resource in <networking/main.tf> file.


# This data source enables to assign random Availability zone for each subnet which mitigates running out of AZs.

data "aws_availability_zones" "available" {}  # Referenced in aws_subnet resource.


- Create random_shuffle resource to randomly shuffle AZs and assign subnet to each shuffled AZs so I don't run out of AZs.


resource "random_shuffle" "public_az" {
  input        = data.aws_availability_zones.available.names    # Referenced to AZ data source above.
  result_count = var.max_subnets    # Referenced to max_subnets in <networking/variables.tf>
}


# This resource creates public Subnets.

resource "aws_subnet" "mtc_public_subnet" {
  count                   = var.public_sn_count   # Referenced from <root/main.tf> "networking" module and variables.tf file.
  vpc_id                  = aws_vpc.mtc_vpc.id    # Referenced from <root/main.tf> "networking" module and variables.tf file.
  cidr_block              = var.public_cidrs[count.index] # Pulls the cidr blocks one by one and assigns to each subnet.
  map_public_ip_on_launch = true                  # Automatically maps public IP to public subnet on launch.
  availability_zone       = random_shuffle.public_az.result[count.index]  # Referenced from random_shuffle resource above.

  tags = {
    Name = "mtc_public_${count.index + 1}"
  }
}

# This resource creates private Subnets.

resource "aws_subnet" "mtc_private_subnet" {
  count                   = var.private_sn_count  # Referenced from <root/main.tf> "networking" module and variables.tf file.
  vpc_id                  = aws_vpc.mtc_vpc.id    # Referenced from <root/main.tf> "networking" module and variables.tf file.
  cidr_block              = var.private_cidrs[count.index]  # Pulls the cidr blocks one by one and assigns to each subnet.
  map_public_ip_on_launch = false                 # Doesn't map public IP on launch thus it becomes private subnet.
  availability_zone       = random_shuffle.public_az.result[count.index]  # Referenced from random_shuffle resource above.

  tags = {
    Name = "mtc_private_${count.index + 1}"
  }
}


- Run <terraform fmt -recursive> to format and clean the code.
- Run <terraform init> to initialize plugins and new resources.
- Run <terraform validate> to validate the code.
- Run <terraform plan> to see which resources will be created.
- Run <terraform apply --auto-approve> to deploy the resources.
- Run <terraform destroy --auto-approve> to destroy the resources.

----------------------------------------------------------------------------------------------------------

